首先通过课程视频介绍，聚集是通过hash来提高效率，外部的hash,将哈希表放到磁盘。先过滤再hash.分别放到不同的桶里面。第二步时rehash，一个hash可能产上碰撞，对第
一次发生碰撞的在进行hash。去重复可以先去重再hash，也可以hash再去重。求平均的值的话，记录个数和总和值。

第一个是实现聚合执行器aggregation_executor：声明了一个SimpleAggregationHashTable类型的成员变量aht_。这个简单聚合哈希表的作用是在聚合操作期间保存中间结果。具体来说，它用于存储正在聚合的键值对，其中键是AggregateKey类型，值是AggregateValue类型。通过
while(child_executor_->Next(&child_tuple,&rid)){
       aht_.InsertCombine(MakeAggregateKey(&child_tuple), MakeAggregateValue(&child_tuple));初始化它。插入聚合键和聚合键的值。
}
Next就是返回下一个元组，包含聚合键和聚合键的值。

再次观看对应视频，JOIN算子，用相等的谓词内连接，小表放左侧作为外表。推迟物化和直接物化。最低效的方式是两层循环枚举外层和内层进行比较是否满足链接方式，然后再连接。BLOCK NESTED LOOP JOIN连接方式以块的方式遍历。一个页用作输出，B-1个页用来缓存，B-2缓存外层，一个页面缓存内表。第三章INDEX NESTED LOOP JOIN索引嵌套循环连接，内表有现存索引就可以直接去查索引。尽量小表做外表，缓存外表越多越好。SORT-MERGE JOIN第四种链接，先排序再双指针比较。布隆过滤器，很可能出现没有链接的情况，先通过过滤器过滤掉不可能连接的页。HASH join,将两个表都进行hash，如果两个表可以连接，那么他们hash后肯定在同一个桶里面。如果hash后还是太大那么在进行hash。

实现两个函数分别是左连接和内连接 ,左连接首先将左表的所有列添加到输出元组中，然后将右表中不存在的列添加为NULL值。这样做是为了确保输出的元组包含左表的所有列，而右表中不存在的列会被填充为NULL，以满足左连接的要求。内连接InnerJoinTuple函数用于生成内连接的输出元组。它首先将左表的所有列添加到输出元组中，然后将右表的所有列添加到输出元组中。这样做是为了确保输出的元组包含了左表和右表的所有列，以满足内连接的要求。Next中，先判断左表是不是遍历完。遍历完直接返回，否者遍历右表，然后判断是否满足连接条件，满足链接，不满足就继续遍历，如果右表也遍历完但是还没有匹配的项如果是左连接可以加入空值，否则就要返回false了.

第一个函数中的Init出错导致没通过第七个案例 没有判断
if (aht_.Size() == 0 && GetOutputSchema().GetColumnCount() == 1) {
    aht_.InsertEmptyCombine();
}
条件判断是为了处理一种特殊情况：当聚合哈希表为空，并且输出模式中只有一个列时。在这种情况下，可能存在一种情况，即输入数据集为空，但是仍然需要生成一个包含聚合结果的输出元组。为了满足这种情况，代码执行了InsertEmptyCombine()方法，向聚合哈希表中插入一个空的聚合值。